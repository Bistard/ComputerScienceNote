# 属性`(Attribute)`的前世今生

其实`C++`早在 [pre03] 甚至更早的时候就已经有了属性的需求。彼时，当程序员需要和编译器沟通，为某些实体添加一些额外的信息的时候，为了避免“发明”一个新的关键词乃至于引起一些语法更改的麻烦，同时又必须让这些扩展内容不至于“污染”标准的命名空间，所以标准保留了一个特殊的用户命名空间——“双下划线关键词”，以方便各大编译器厂商能够根据需要添加相应的语言扩展。根据这个标准，各大编译器厂商都做出了自己的扩展实现，目前在业界广泛使用的属性空间有`GNU`和IBM`的 ``attribute(())`，微软的 `__declspec()`，甚至C#还引入了独特的单括号系统` (single bracket system) `来完成相应的工作。

随着编译器和语言标准的发展，尤其是`C++`多年来也开始逐渐借鉴其他语言中的独特扩展，属性相关的扩展也越来越庞大。但是`Attribute`的语法强烈依赖于各大编译器的具体实现，彼此之间并不兼容，甚至部分关键属性导致了语言的分裂，最终都会让使用者的无所适从。所以在`C++11`标准中，特意提出了`C++`语言内置的属性概念。提案大约是在`2007`年前后形成，`2008`年`9`月`15`日的提案版本n2761被正式接纳为`C++11`标准中的`Attribute`扩展部分（此处历史略悠久，很可能有不准确的部分，欢迎各位指正）。

> Attributes provide the unified standard syntax for implementation-defined language extensions, such as the GNU and IBM language extensions `__attribute__((...))`, Microsoft extension `__declspec()`, etc.

# 属性的语法定义

正如我们在上一节讨论的，属性的关键要求就是避免对标准用户命名空间的污染，同时对于未来可能引入的更多属性，我们需要有一个方式可以避免新加的“属性关键字”破坏当前已有的`C++`语法。所以新标准采用了“双方括号”的语法方式引入了属性说明，比如`[[noreturn]]`就是一个标准的`C++`属性定义。而未来新属性的添加都被控制在双方括号范围之内，不会进入标准的命名空间。

按照C++语言标准，下列语言实体可以被属性所定义/并从中获益：

- 函数
- 变量
- 函数或者变量的名称
- 类型
- 程序块
- Translation Unit （这个不知道用中文咋说）
- 程序控制声明

**<u>根据C++的标准提案，属性可以出现在程序中的几乎所有的位置</u>**。

当然属性出现的位置和其修饰的对象是有一定关联的，属性仅在合适的位置才能产生效果。

* 比如`[[noreturn]`必须出现在函数定义的位置才会产生效果，如果出现在某个变量的声明处则无效。

根据C++17的标准，未实现的或者无效的属性均应该被编译器忽略且不产生任何错误报告（在C++17标准之前的编译器则参考编译器的具体实现会有不同的行为）。

# 目前C++标准中引入的标准属性

**C++11**

* `[[noreturn]]`
* `[[carries_dependency]]`

**C++14**

* `[[deprecated]]`
* `[[deprecated("reason")]]`

**C++17**

* `[[fallthrough]]`
* `[[nodiscard]] `
* ` [[nodiscard("reason")]] (C++20)`
* `[[maybe_unused]]`

`C++20`

- `[[likely]]`
- `[[unlikely]]`
- `[[no_unique_address]]`

---

该章包括子章节大部分内容摘抄于：

* https://en.cppreference.com/w/cpp/language/attributes
* https://www.zhihu.com/search?type=content&q=C%2B%2B%20attribute